# 秒杀系统

本系统关注点只在于后端技术，暂不讨论前端的相关可行操作

秒杀系统的关键在于，如果在高并发的情况下，对于共享资源的保护，在保证线程安全的前提下，还要尽可能地减少锁的粒度，以下是从三个不同的角度来实现锁对于共享资源的保护

- 基于MySQL
- 基于Redis
- 基于ZooKeeper

首先，对于上面三种方案，在单机的情况下，使用多线程并发的情况，模拟高并发抢购的场景。有兴趣的朋友可以到www.jayna.fun进行测试。

#### 方案一：最简单MysSQL锁住资源

利用MySQL更改数据的时候，会使用行锁锁住资源，但是可能存在的一个问题是，瞬时的高并发访问MysSQL数据库，会不会使得服务器崩溃呢？如果采用分布式存储数据，缓解单机数据库访问的压力，这肯定又会造成代码的复杂性，因为必须保证分布式数据库中数据的一致性。

关键SQL语句如下：

```sql
	UPDATE goods SET count = count - buyNum where count >= buyNum and id = goodsId; 
```

#### 方案二：Redis实现锁

- Redis集群可以从缓解大量用户访问瞬时访问一个Redis的压力
- 基于内存的数据读写，性能优于MySQL数据库

组合下面几个Redis命令，来完成Redis锁：

```sql
redis > setnx lockName exipreTime	//成功返回1，失败返回0
redis > getset lockName expireTime	//１.lockName存在返回旧值，否则抛出异常
									//2.设置lockName的新值为expireTime
redis > get lock_name				//返回lockName的过期
redis > del lock_name				//释放锁
```

Redis锁的具体实现如下：

```java
public class RedisLock {
    private static JedisClusterUtil jedisClusterUtil = new JedisClusterUtil();
    private static Random random = new Random(47);
    private static long interval = 3000;


    public boolean tryLock(String mutex, long timeout){
        Long current = System.currentTimeMillis();
        timeout *= 1000;
        try{
            while (true){
                if((System.currentTimeMillis()-current) > timeout)
                    break;
                else{
                    if(innerTryLock(mutex))
                        return true;
                    else
                        Thread.sleep(200 + random.nextInt(300));
                }
            }
        }catch (Exception e){
            e.printStackTrace();
        }

        return false;
    }

    public void releaseLock(String mutex){
        jedisClusterUtil._del(mutex);
    }

    private boolean innerTryLock(String mutex){
        try{
            long now = System.currentTimeMillis();
            String expireTime = String.valueOf(now + interval);
            if(jedisClusterUtil._setnx(mutex, expireTime) == 1){
                return true;
            }
            else{
                if(checkIfLockTimeout(mutex, now)){
                    String expect = jedisClusterUtil._get(mutex);
                    String preExpireTime = jedisClusterUtil._getSet(mutex, expireTime);
                    if(preExpireTime != null && preExpireTime.equals(expect)){
                        return true;
                    }
                }
                return false;
            }

        }catch (Exception e){
            e.printStackTrace();
        }
        return false;
    }


    private boolean checkIfLockTimeout(String mutex, long timeStamp){
        return timeStamp > Long.valueOf(jedisClusterUtil._get(mutex));
    }
}
```

#### 方案三：ZooKeeper实现锁




```java
public class ZooKeeperLock {
    private static Logger logger = Logger.getLogger(ZooKeeperLock.class.getName());
    /*
        /zk-locks
                 /milk
                      /number-1
                      /number-2
                      /number-3
                      .
                      .
                      .

                /apple
                      /number-1
                      /number-2
                      .
                      .
                      .
     */

    private final String ROOT_PATH = "/zk-locks";
    private final String NUMBER = "/number";
    private Map<Thread, String> threadLockMap;
    private String lockLabel;
    private CuratorFramework client;

    public ZooKeeperLock(String connectString, String lockLabel){
        try{
            threadLockMap = new HashMap<>();
            this.lockLabel = "/" + lockLabel;
            RetryPolicy retryPolicy = new ExponentialBackoffRetry(5000, 5);
            client = CuratorFrameworkFactory.newClient(connectString, 60000, 10000, retryPolicy);
            client.start();
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public void lock(Runnable work){
        try{
            String currentLock = client.create()
                    .creatingParentsIfNeeded()
                    .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)
                    .forPath(ROOT_PATH + lockLabel + NUMBER);

            String index = currentLock.substring(currentLock.lastIndexOf("/") + 1);
            List<String> brotherNodes = client.getChildren().forPath(ROOT_PATH + lockLabel);
            Collections.sort(brotherNodes);

            String prevNode = null;
            for(int i = brotherNodes.size()-1; i >= 0; --i){
                if(brotherNodes.get(i).compareTo(index) < 0){
                    prevNode = brotherNodes.get(i);
                    break;
                }
            }

//            System.out.println("**********************************************************");
//            System.out.println(Thread.currentThread().getName() + "-创建节点:" + index + ", 前一个节点是:" + prevNode);
//            System.out.println("**********************************************************");

            threadLockMap.put(Thread.currentThread(), currentLock);

            if(prevNode == null){
                work.run();
                return;

            } else{
                final String watchPath = ROOT_PATH + lockLabel + "/" + prevNode;
                final NodeCache cache = new NodeCache(client, watchPath, false);
                cache.start(true);
                cache.getListenable().addListener(new NodeCacheListener() {
                    @Override
                    public void nodeChanged() throws Exception {
//                        System.out.println("------------------------------------------------------------------");
                        work.run();
//                        System.out.println(Thread.currentThread().getName() + "-"+ threadLockMap.get(Thread.currentThread()) +", CacheNode被触发, 被删除的节点:" + cache.getPath());
//                        System.out.println("------------------------------------------------------------------");

                    }
                });
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }



    public void release(){
        try{
            String currentPath = threadLockMap.get(Thread.currentThread());

            if(currentPath != null && client.checkExists().forPath(currentPath) != null){
                client.delete().guaranteed().forPath(currentPath);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
```